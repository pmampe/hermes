/*
 * Copyright (c) 2013, IT Services, Stockholm University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * Neither the name of Stockholm University nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

import java.nio.charset.Charset;

import groovy.json.JsonSlurper
import javax.net.ssl.HttpsURLConnection

import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.methods.HttpPut
import org.apache.http.impl.auth.BasicScheme;
import org.apache.http.impl.client.AbstractHttpClient;
import org.apache.http.impl.client.DefaultHttpClient
import org.apache.http.entity.mime.MultipartEntity
import org.apache.http.entity.mime.HttpMultipartMode;
import org.apache.http.entity.mime.content.FileBody
import org.apache.http.entity.mime.content.StringBody
import org.apache.http.HttpHost;
import org.apache.http.HttpVersion
import org.apache.http.params.CoreProtocolPNames
import org.apache.http.protocol.BasicHttpContext;
import org.apache.http.HttpResponse
import org.apache.http.util.EntityUtils
import org.apache.tools.ant.filters.*

import org.eclipse.jgit.lib.Repository
import org.eclipse.jgit.storage.file.FileRepositoryBuilder
import org.eclipse.jgit.revwalk.RevWalk

import com.eriwen.gradle.js.JsMinifier
import com.eriwen.gradle.css.CssMinifier

apply plugin: 'saga'
apply plugin: 'js'
apply plugin: 'css'
apply plugin: 'release'

println "Building ${artifact.capitalize()} v${version}."

loadConfiguration()

/**
 * Wrapper
 */
task wrapper(type: Wrapper) {
  gradleVersion = '1.6'
}

javascript.source {
  prod {
    js {
      srcDir file('assets/www/')
      include "**/*.js"
      exclude '**/cordova*.js', '**/GAPlugin*.js', '**/*.min.js', '**/*-min.js', '**/spec/*'
    }
  }
}

css.source {
  prod {
    css {
      srcDir file('assets/www')
      include '**/*.css'
      exclude '**/*.min.css', '**/spec/*'
    }
  }
}

/**
 * Coverage
 */
saga {
  baseDir = file('assets/www/')
  outputDir = file('build/reports/coverage')
  includes = '**/*spec.html'
  noInstrumentPatterns = [".*/cordova.*\\.js", ".*/GAPlugin.*\\.js", ".+\\/lib\\/.*", ".+\\/spec\\/.*"]
  sourcesToPreload = "**/*.js"
}

coverage.doLast {
  "cp -v build/reports/coverage/total-coverage.dat build/reports/coverage/jsTestDriver.conf-coverage.dat".execute()
}

/**
 * Sonar integration
 */
task buildSonarPom(type: Copy) {
  from 'pom.xml.dist'
  into '.'

  rename(/(.+).dist/, '$1')
  filter(ReplaceTokens, tokens: [
          group: project.group,
          name: project.artifact,
          version: project.version,
          description: project.description
  ])
}

/**
 * Minify js & css
 */
task minify() {
  doLast {
    javascript.source.prod.js.files.each { File file ->
      def dest = new File(file.absolutePath.replaceAll(/\.js$/, '.min.js'))

      new JsMinifier().minifyJsFile(
              [file] as Set<File>,
              [] as Set<File>,
              dest,
              project.closure.compilerOptions,
              project.closure.warningLevel,
              project.closure.compilationLevel
      )
    }

    css.source.prod.css.files.each { File file ->
      def dest = new File(file.absolutePath.replaceAll(/\.css$/, '.min.css'))

      new CssMinifier().minifyCssFile(
              file,
              dest,
              project.yuicompressor.lineBreakPos
      )
    }
  }
}

/**
 * Run JSHint
 */
task jshintTask(type: com.eriwen.gradle.js.tasks.JsHintTask) {
  source = javascript.source.prod.js.files
  dest = "${buildDir}/reports/jshint.xml"
  reporter = 'checkstyle'
  jshint.options = ["undef": true, "unused": true]
  jshint.predef = [
          'window': true,
          'document': true,
          'navigator': true,
          '$': true,
          '_': true,
          'Backbone': true,
          'gaPlugin': true,
          'i18n': true,
          'google': true,
          'FastClick': true,
          'JST': true,
          'suApp': true
  ]
}

/**
 * Run csslint
 */
task csslintTask(type: com.eriwen.gradle.css.tasks.CssLintTask) {
  source = css.source.prod.css.files
  dest = "${buildDir}/reports/csslint.xml"
  csslint {
    format = 'lint-xml'
    errors = []
  }
}

/**
 * Run tests
 */
task test(type: Exec) {
  def testExecScript = file('assets/www/spec/lib/phantom-jasmine/run_jasmine_test.coffee')
  def testRunner = file('assets/www/spec.html')

  commandLine config.phantomjs(), testExecScript.absolutePath, testRunner.absolutePath
}

/**
 * Generate test reports
 */
task testReports(type: Exec) {
  def testExecScript = file('assets/www/spec/lib/jasmine-reporters/phantomjs-testrunner.js')
  def testRunner = file('assets/www/spec.html')

  commandLine config.phantomjs(), testExecScript.absolutePath, testRunner.absolutePath
}

/**
 * JSDoc
 */
task jsdocjs(type: com.eriwen.gradle.js.tasks.JsDocTask) {
  source = fileTree(
          dir: "${projectDir}/assets/www/",
          include: "**/*.js",
          excludes: ['**/cordova*.js', '**/lib/**/*.js']
  ).getFiles().collect { File f -> f.path; }
  destinationDir = file("${buildDir}/jsdoc")
}

/**
 * Copy ios 320x480 splash to default splash
 */
task copySplash(type: Copy) {
  from('assets/www/splash/ios/splash_320x480.png') {
    rename 'splash_320x480.png', 'splash.png'
  }
  into 'assets'
}

/**
 * Build a phonegap tar
 */
task build(type: Tar, dependsOn: [test, minify, copySplash]) {
  archiveName archiveFile
  compression Compression.GZIP
  includes = [
          'www/',
          'splash.png'
  ]
  excludes = [
          'www/spec.html',
          'www/spec',
          '**/cordova*.js',
          '**/GAPlugin.js'
  ]
  exclude({
    def ret = false
    def name = it.file.name

    if (name ==~ /.*\.js/ && !name ==~ /.*(\.|-)min\.js/) {
      ret = true
    }

    if (name ==~ /.*\.css/ && !name ==~ /.*\.min\.css/) {
      ret = true
    }

    ret
  })
  from new File("assets/")

  eachFile { FileCopyDetails fileCopyDetails ->
    if (!fileCopyDetails.isDirectory()) {
      if (fileCopyDetails.name ==~ /.*\.html/) {
        fileCopyDetails.filter { String line ->
          def ret = line.replaceAll(/cordova-.*\.js/, 'phonegap.js')

          // Replace js includes with minified js file
          if (ret ==~ /.*\.js.*/ && !(ret ==~ /.*phonegap\.js.*/ || ret ==~ /.*GAPlugin\.js.*/ || ret ==~ /.*(\.|-)min\.js.*/)) {
            ret = ret.replaceAll(/\.js/, '.min.js')
          }

          // Replace css includes with minified css file
          if (ret ==~ /.*\.css.*/ && !(ret ==~ /.*\.min\.css.*/)) {
            ret = ret.replaceAll(/\.css/, '.min.css')
          }

          ret
        }
      } else if (fileCopyDetails.relativePath.pathString == "www${File.separator}config.xml") {
        fileCopyDetails.filter(ReplaceTokens, tokens: [
                id: project.group + '.' + project.name,
                appName: config.appName,
                version: project.version.replaceAll(/-SNAPSHOT/, "b" + getCurrentRev()),
                versionCode: versionCode,
                description: project.description
        ])
      } else if (fileCopyDetails.relativePath.pathString == "www${File.separator}js${File.separator}config.js") {
        fileCopyDetails.filter { String line ->
          line.replaceAll(/http:\/\/mobileapp-dev.it.su.se\/geo/, config.geoUrl)
        }
      }
    }
  }
}

build {
  // Always rebuild tar.
  outputs.upToDateWhen { false }

  doFirst {
    // Remove old zip file
    def zipFile = new File(archiveFile)
    zipFile.delete()
  }

  doLast {
    println "Archive created at '$archiveName'"
  }
}

/**
 * Send app to Phonegap Build
 */
task toPhonegap(dependsOn: build) {
  doLast {

    if (!config.phonegapPassword) {
      def console = System.console()
      if (console) {
        config.phonegapPassword = console.readPassword("\n> Password for ${phonegapUser}: ").toString()
      }
    }

    def host = "build.phonegap.com"
    def apiCall = "https://build.phonegap.com/api/v1/apps/${phonegapAppId}"

    DefaultHttpClient httpclient = new DefaultHttpClient();

    // -- AUTHENTICATION --
    AuthScope authScope = new AuthScope(host, 443);
    UsernamePasswordCredentials upc = new UsernamePasswordCredentials(
            phonegapUser, config.phonegapPassword);
    ((AbstractHttpClient) httpclient).getCredentialsProvider()
            .setCredentials(authScope, upc);
    BasicHttpContext localContext = new BasicHttpContext();
    BasicScheme basicAuth = new BasicScheme();
    localContext.setAttribute("preemptive-auth", basicAuth);
    HttpHost targetHost = new HttpHost(host, 443, "https");
    // -- AUTHENTICATION END

    // Header info
    httpclient.getParams().setParameter(CoreProtocolPNames.PROTOCOL_VERSION, HttpVersion.HTTP_1_1);
    HttpPut httpPut = new HttpPut(apiCall)
    httpPut.getParams().setBooleanParameter(CoreProtocolPNames.USE_EXPECT_CONTINUE, true)
    httpPut.setHeader("Accept", "*/*")

    // Multipart request - one part containing info to unlock keys, one part containing app file
    MultipartEntity mp = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
    StringBody stringBody = new StringBody("""{"keys":
      {"android":{"id":$androidCertKeyId, "key_pw": "$config.phonegapKey", "keystore_pw": "$config.phonegapKey"},
      "ios":{"id":$iOSCertKeyId, "password": "$config.phonegapKey"}
      }
    }""",
            "application/json", Charset.forName("utf-8"))
    mp.addPart('data', stringBody);
    FileBody fileBody = new FileBody(new File(archiveFile), "binary/octet-stream");
    mp.addPart('file', fileBody);
    httpPut.setEntity(mp); // add the two parts to the request
    // execute request
    HttpResponse response = httpclient.execute(targetHost, httpPut, localContext)

    def status = response.statusLine.statusCode
    def json = new JsonSlurper().parseText(EntityUtils.toString(response.entity))

    if (json?.error?.size() > 0) {
      throw new Exception("Error during publish to phonegap: ${json.error}")
    } else if (status != 200) {
      throw new Exception("Failed to publish to phonegap: (${json.error}) ${status}: ${response.statusLine.reasonPhrase}")
    } else {
      println "Successfully published app '${json.title}' v${json.version} build nr ${json.build_count} to phonegap."
    }
  }
}

/**
 * Increment android versionCode
 */
task incrementVersionCode() {
  doLast {
    def oldCode = versionCode
    def newCode = oldCode.toInteger() + 1

    project.ant.replace(
            file: new File('gradle.properties'),
            token: "versionCode=${oldCode}",
            value: "versionCode=${newCode}",
            failOnNoReplacements: true
    )
  }
}

// Release plugin depends on incrementing version code & sending build to phonegap.
createReleaseTag.dependsOn incrementVersionCode, test

def getCurrentRev() {
  FileRepositoryBuilder builder = new FileRepositoryBuilder();
  Repository repository = builder.setGitDir(new File(projectDir.absolutePath + File.separator + ".git"))
          .readEnvironment() // scan environment GIT_* variables
          .findGitDir() // scan up the file system tree
          .build();

  RevWalk walk = new RevWalk(repository);
  walk.markStart(walk.parseCommit(repository.resolve("HEAD")));

  walk.next().getId().name()[0..6]
}

/**
 * Load environment aware config
 */
def loadConfiguration() {
  ext.environment = hasProperty('env') ? env : 'dev'
  println "Environment is set to $environment"

  def configFile = file('config.groovy')
  ext.config = new ConfigSlurper(environment).parse(configFile.toURL())
}

/**
 * Config
 */
buildscript {
  repositories {
    maven {
      url = 'http://kellyrob99.github.com/Jenkins-api-tour/repository'
    }
    mavenCentral()
  }
  dependencies {
    classpath 'org.apache.httpcomponents:httpclient:4.2.1'
    classpath 'org.apache.httpcomponents:httpmime:4.2.1'
    classpath 'com.github.timurstrekalov:gradle-saga-plugin:1.4.1'
    classpath 'com.eriwen:gradle-js-plugin:1.5.0'
    classpath 'com.eriwen:gradle-css-plugin:1.2.1'
    classpath 'com.github.townsfolk:gradle-release:1.2'
    classpath 'org.eclipse.jgit:org.eclipse.jgit:2.3.1.201302201838-r'
  }
}

repositories {
  mavenCentral() //needed by the plugin to retrieve the jslint jar
}
